# Projet shiny _ MPG
library(shiny)
library(readxl)
library(dplyr)
require(data.table)
library(tidyverse)
library(tidyr)

# pour optimisation lineaire 
library(dplyr)
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)

library(DT)       # tableau stylé dans factoshiny
library(shinyjs)  # Pour cacher le sidebarPanel
library(stringi)



setwd("~/Projets_M2/Projet_MPG")



###################################################
############### Importation jdd ###################
###################################################

note_mpg2 = read.table("mpg_stats_07_03.csv", sep = ";", header = TRUE)

head(note_mpg2)

######## SHOULD BE FIX IF CSV FILE IS UPDATED   ######## 

colnames(note_mpg2) = c("Joueur", "Poste", "Cote", "Note", "Variation", "But" ,"j28"  ,"j27", "j26" , "j25","j24", "j23",
                         "j22" , "j21", "j13", "j12" ,"j11","j10" , "j9" , "j8","j7",
                         "j6", "j5", "j4",  "j3", "j2","j1",   "DMI" ,"Club", "Prochain.opposant" , "Victoire.probable") 
note_mpg =  note_mpg2[,1:29]

###### END FIX ######


head(note_mpg)

# TOP 5 des supersub --
n = 5
## Convert variables
note_mpg$Poste = as.factor(note_mpg$Poste)
note_mpg$Cote = as.numeric(note_mpg$Cote)


note_mpg$But  = stri_extract_first_regex(note_mpg$But, "[0-9]+")
note_mpg$But = as.numeric(note_mpg$But)
note_mpg$Club = as.factor(note_mpg$Club)

# Convert variables starting with "J-"
colJ_num = grepl("j", names(note_mpg))
note_mpg[ , colJ_num] =  apply( note_mpg[ ,colJ_num], MARGIN = 2 , FUN = extract_numeric)
note_mpg[ , colJ_num] =  abs(note_mpg[ ,colJ_num])

head(note_mpg)

### on enlève les joueurs qui ont des NA en cote (c'est suite a un transfert) ###
note_mpg<-note_mpg[complete.cases(note_mpg[,2]),]

#######################################
######### mutliplicateur de perf ######
#######################################
j = 21
#### On cherche a apporter plus d'importance aux performances recente 
jour = seq(1,j)
beta =log((jour+1)) # beta est notre conficient multiplicateur de performance par journee
plot_beta = plot(jour,beta, main = "Coefficient beta en fonction de la journée de ligue 1")

note = note_mpg[ , colJ_num]                     #tableau avec les note par journee 
note_beta = data.frame(mapply(`*`,note,beta))    #tableau avec les note * beta par journee

# on applique mtn la fonction sum par ligne pour avoir la perf total du joueur : 
performance_beta = apply(note_beta ,MARGIN = 1, FUN = sum, na.rm = TRUE)
performance = apply(note ,MARGIN = 1, FUN = sum, na.rm = TRUE)

# on concatene nos vecteurs performance, performance beta par joueurs
perf = cbind(note_mpg$Joueur, performance, performance_beta)
perf= as.data.frame(perf)
perf$V1 = as.factor(perf$V1)
perf$performance = as.numeric(perf$performance)
perf$performance_beta = as.numeric(perf$performance_beta)

# Puis on merge sur le data frame
note_mpg = merge(note_mpg, perf, by.x = "Joueur", by.y = "V1" )

perf = note_mpg[order(-note_mpg$performance_beta),]
head(perf[which(perf$Poste == "D"),c("Joueur", "Cote", "But", "performance_beta")],30)


###########################################
######### Multiplicateur de cote ##########
###########################################

## on souhaite que l'enchère sur les joueurs les plus cotés soit plus important que les autres ###

### on sélectionne la plage des x ###
x_cote=seq(1,max(note_mpg$Cote))

## choix de la pondération à partir des cotes joueurs ###
alpha=exp(x_cote/20)/10 +1.3
plot_alpha = plot(x_cote,alpha, main = "Coefficient Alpha en fonction de la cote initial du joueur")


## petite boucle qui permet de multiplier la cote du joueur au alpha qui correspond ###
cote_alpha <- NULL
for (i in 1:length(note_mpg$Cote)){
  cote_alpha[i] <- note_mpg$Cote[i] * alpha[note_mpg$Cote[i]]
}

## on arrondi les cotes ##
cote_alpha = round(cote_alpha,0)


# On rajoute la cote_alpha au data frame note_mpg
note_mpg$cote_alpha = cote_alpha


########################################
######### Classement - TOP 10 ##########
########################################

# Top 10 des Buteurs ---
n = 10
top_buteur = note_mpg[,c("Poste", "Joueur", "But", "Cote")]
top_buteur = top_buteur[order(-top_buteur$But),]
top_buteur = top_buteur[1:n,]

# Top 10 des performant ---
n = 10
top_perf = note_mpg[,c("Poste", "Joueur", "performance_beta", "Cote")]
top_perf = top_perf[order(top_perf$performance_beta),]
top_perf = top_perf[1:n,]

# Top 10 des Joueurs les plus chers ---
n = 10
top_cote = note_mpg[,c("Poste", "Joueur","Club", "Cote", "cote_alpha")]
top_cote = top_cote[order(-top_cote$cote_alpha),]
top_cote = top_cote[1:n,]


# Top 10 des Joueurs les plus reguliers --
n = 10
top_moy = note_mpg[,c("Poste", "Joueur", "Club", "performance_beta")]
top_moy = top_moy[order(-top_moy$performance_beta),]
top_moy = top_moy[1:n,]


## Top 10 des gardiens--
n = 10
top_G = note_mpg[c(note_mpg$Poste=="G"),c("Poste","Joueur", "Club","performance_beta")]
top_G = top_G[order(-top_G$performance_beta),]
top_G = top_G[1:n,]


## TOP 10 des déf ---
top_def = note_mpg[c(note_mpg$Poste=="D"),c("Poste","Joueur", "Club","performance_beta")]
top_def = top_def[order(-top_def$performance_beta),]
top_def = top_def[1:n,]


## TOP 10 des milieux --
n = 10
top_mil = note_mpg[c(note_mpg$Poste=="M"),c("Poste","Joueur", "Club", "performance_beta")]
top_mil = top_mil[order(-top_mil$performance_beta),]
top_mil = top_mil[1:n,]


## TOP 10 des attaquants ---
n = 10
top_att = note_mpg[c(note_mpg$Poste=="A"),c("Poste","Joueur", "Club", "performance_beta")]
top_att = top_att[order(-top_att$performance_beta),]
top_att = top_att[1:n,]


# TOP 10 des perles rares (cote basses, buts ou moyenne bonne)--
n= 10
perle =  note_mpg[,c("Poste","Joueur", "Club", "performance_beta","Cote")]
perle$Ratio = perle$performance_beta/perle$Cote
top_perle= perle[order(-perle$Ratio),]
top_perle = top_perle[1:n,]



#### Optimisation lienaire : OMPR 
n = dim(note_mpg)[1]
nb_joueurs = 2+6+6+4
maxG = 15
# Pour selectionner les joueurs desiré

perf = scale(note_mpg$performance_beta ) *2
cote = note_mpg$cote_alpha
poste = as.character(note_mpg$Poste)
note_mpg$But[is.na(note_mpg$But)] <- 0
buts = scale(note_mpg$But)

results = MIPModel() %>%
  add_variable(z[i], i = 1:n, type = "binary") %>%
  set_objective(sum_expr((perf[i] + buts[i]) * z[i], i = 1:n), "max") %>%
  add_constraint(sum_expr(z[i], i = 1:n) == nb_joueurs) %>%
  add_constraint(sum_expr(cote[i] * z[i], i = 1:n) <= 500)  %>%
  add_constraint( sum_expr(z[i], i = 1:n, poste[i] == "G") == 2) %>%
  add_constraint( sum_expr(z[i], i = 1:n, poste[i] == "D") == 6) %>%
  add_constraint( sum_expr(z[i], i = 1:n, poste[i] == "M") == 6) %>%
  add_constraint( sum_expr(z[i], i = 1:n, poste[i] == "A") == 4) 


contraint3 = as.expression(sum_expr(z[i], i = 1:n, poste[i] == "G"))
contraint4 = as.expression(sum_expr(z[i], i = 1:n, poste[i] == "D"))
contraint5 = as.expression(sum_expr(z[i], i = 1:n, poste[i] == "M"))
contraint6 = as.expression(sum_expr(z[i], i = 1:n, poste[i] == "A"))


results$constraints[[3]]$lhs =contraint3
results$constraints[[4]]$lhs =contraint4
results$constraints[[5]]$lhs =contraint5
results$constraints[[6]]$lhs =contraint6


results = solve_model(results , with_ROI(solver = "glpk"))
results = get_solution(results, z[i])
results = filter(results, value > 0)


mercatoEx = note_mpg[results$i,c("Poste", "Joueur", "performance_beta", "Cote", "cote_alpha", "But")]
mercatoEx = mercatoEx[order(mercatoEx$Poste),]
mercatoEx

